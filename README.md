# mdb-v2-backend
Backend for ModelDB version 2

### Project build & execution Steps:

**Note** : This project requires **JAVA version 8** to run. Please setup and configure JAVA version 8 prior to running and then run following below mentioned steps.

```
1) mvn clean
```

If you have not configured protocol buffer compiler in your POM as a build extension, then you would need to download protocol buffer compiler and set the compiler path in your system path. Then, run below commands for all .proto files in order to generate Java code from .proto files.

```
2) protoc --proto_path=src/main/proto --java_out="output_folder_path" ".proto file path"

	ex:- protoc --proto_path=src/main/proto --java_out=src/main/protogen src/main/proto/ProjectService.proto
```

Since current codebase has proto buffer compiler already setup in POM, no need to run the protoc command as above, You can straight continue to the following command

```
2) mvn package 
	OR Run All JUnit Test case : mvn test 
	OR Run single test using : mvn -Dtest=TestName test
	OR Exclude JUnit Test case with maven package then use : mvn package -Dmaven.test.skip=true
```

Run gRPC server use following command

```
3) mvn exec:java -Dexec.mainClass=com.mitdbg.modeldb.App
```

### Code Coverage Reports: 

Create code coverage reports by the following commands

```
mvn clean test
```

Show the created code coverage report for unit tests from following package directory, it has module wise code coverage report in 'html' format after executing unit tests

```
"target/site/jacoco-ut"
```

### Code analytics & coverage reports using SonarQube:

Download SonarQube from following URL

```
https://www.sonarqube.org/downloads/
```

How to start SonarQube for view the analytics & coverage use following URL

```
https://docs.sonarqube.org/latest/setup/get-started-2-minutes/
```

Create code analytics & coverage reports by the following commands

```
mvn clean package sonar:sonar
```

Show the created code analytics & coverage report for the project from following link

```
http://localhost:9000/dashboard?id=com.mitdbg.modeldb%3Amodeldb
```

### Build maven jar artifact

There is two jar support
1) One is regular JAR supported by maven build and this jar doesn't contains other library.
2) Second jar is single JAR generated by spring-boot maven build, this JAR contains all the other maven library.

Build JAR path is following :

```
1) "target/modeldb-1.0-SNAPSHOT.jar" - without other library maven build

2) "target/modeldb-1.0-SNAPSHOT-client-build.jar" - with all other library spring-boot maven build
```

### Docker setup & Docker Run

If you have [Docker Compose](https://docs.docker.com/compose/install/) installed, you can bring up a ModelDB server with just a couple commands.

Note the following points when the setup docker

- Put the mongo container name from docker-compose file as a mongoDBHost and other database related parameter like mongoDBPort,mongoDBName, mongoDBUsername, mongoDBPassword etc. in config.yaml file.
- As per docker hub suggestion for the wait-for-it.sh, following link provide documentation of wait-for-it.sh script file.
	1) https://docs.docker.com/compose/startup-order/
	2) https://github.com/vishnubob/wait-for-it

**Use Existing Database**

- Provide your existing database name in config.yaml file and db user credentials, if exists.
- Note: If you provide an existing db user credentials in config.yaml, then make sure that user has 'dbOwner' access control otherwise the system shall throw a runtime exception.
- If you provide db user credential in config.yaml, and your db does not have that user already configured/defined then modeldb backend will create the new user as dbowner in the database.
- If you do not provide db user credential in config.yaml, then modeldb backend will create a default new user (vertaMDBAdmin) as dbowner in the database.

**Use New Database**

- Provide your new database name in config.yaml file with db user credentials. System shall create the new database and new user and password in that database.
- If you do not provide db user credential in config.yaml, then modeldb backend will create a default new user (vertaMDBAdmin) as dbowner in the database.

*To run ModelDB with Docker.*

1. **Clone the repo**

    ```bash
    git clone https://github.com/VertaAI/mdb-v2-backend.git
    ```
2. **Build ModelDB JAR**
	Note: setup maven in you system for build ModelDB executable single jar

    ```
    For Windows --> open CMD --> cd  [path_to_modeldb] --> mvn clean --> mvn package

    For Other --> open TERMINAL --> cd  [path_to_modeldb] --> mvn clean --> mvn package

    Show Build JAR path from [Build maven jar artifact](README.md#Build maven jar artifact).
    ```

2. **Build and run ModelDB & MongoDB**

    ```bash
    cd [path_to_modeldb]
    docker-compose up
    ```

2. **Stop ModelDB & MongoDB**

    ```
    docker-compose down
    ```

3. **Show ModelDB & MongoDB is running**

    ```
    docker container ls -a
    OR
    docker ps
    ```

Note by default ModelDB will listen on **docker-machine-ip:8085** And MongoDB will listen on **docker-machine-ip:27017**
If you want to run ModelDB and MongoDB on other port then expose that port in docker-compose.yaml file as well as put that port number in config.yaml file.

After successfully docker-compose up you can check it using following steps :

- Open system TERMINAL OR CMD
- CD [path_to_modeldb_project]
- run test cases using following command :

```
Run All JUnit Test case : mvn test
	OR Run single test class using : mvn -Dtest=TestClassName test
	OR Run single test case of class using : mvn -Dtest=TestClassName#testCaseMethodName test
	OR Exclude JUnit Test case with maven package then use : mvn package -Dmaven.test.skip=true
```

### Artifact Store gRPC server setup

Configure Host & Port number for ArtifactStore gRPC server like,

```
artifactStore_grpcServer:
  host: localhost OR IP location
  port: 8086
```

**NOTE : **
- We store clientKey, cloudStorageKey and cloudFilePath mapping in separate table/collection **"ArtifactStoreMapping"**.
- ArtifactStore server generate one unique key for cloud storage and then return it to ModelDB server after uploading for store key mapping in ArtifactStoreMapping table.
